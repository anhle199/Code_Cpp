*** When meteprogramming:
- Thông thường sử dụng metaprogramming để loại bỏ bớt các tác vụ .... hoặc dễ bị lỗi. Vd như bạn có thể viết một chương trình mã máy bằng tay thì thay vào đó có thể dùng các NNLT bậc cao để dịch nó sang các đoạn mã máy bậc thấp.


- You want the code to be expressed in terms of the abstractions of the problem domain.
==> Bạn muốn viết đoạn mã trừu tượng cho các vấn đề cụ thể.
- Bạn muốn tận dụng những cái đã có sẵn, xây dựng sẵn.
- Bạn muốn tất cả mọi thứ với C++ mà không cần công cụ.




*** Rules for metaprogramming:
- đối với chương trình thường thì thao tác với data function, còn metaprogram thì thao tác với metadata và metafunction.
- tham số của function được bao trong cặp ( ), đối với metafunction là < >
- function thực hiện ở run-time, metafunction thực hiện ở compile-time
- các biến trong TMP không thực sự là biến:
	VD: struct ValueHolder
	    {
	       enum { value = 2 };
	    };
+ vì các giá trị là hằng số, vì các biểu thức được tính toán tại compile-time nên giá trị phải là constant.
+ có thể đặt tên cho giá trị như các biến thông thường trong lập trình.
+ khi làm việc với type thì tên giá trị là typedef.
	VD: struct ValueHolder
	    {
	       typedef int value;
	    };

- không có biến, không có vòng lặp ==> chỉ đệ quy.



- Loops with recursive template definitions
- Conditionals with partial template specializations
- Returns using typedefs



- Trong metaprogramming có  decltype và declval:
+ decltype trả về kiểu của một đối số (argument)